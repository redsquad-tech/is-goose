# This is a **reuseable** workflow that bundles the Desktop App for Intel macOS.
# It doesn't get triggered on its own. It gets used in multiple workflows:
#  - release.yml
#  - canary.yml
#  - pr-comment-bundle-desktop.yml
on:
  workflow_call:
    inputs:
      version:
        description: 'Version to set for the build'
        required: false
        default: ""
        type: string
      signing:
        description: 'Whether to perform signing and notarization'
        required: false
        default: false
        type: boolean
      quick_test:
        description: 'Whether to perform the quick launch test'
        required: false
        default: true
        type: boolean
      ref:
        type: string
        required: false
        default: ''
    secrets:
      OSX_CODESIGN_ROLE:
        required: false
      OPENAI_API_KEY:
        required: false

name: Reusable workflow to bundle desktop app for Intel Mac

jobs:
  bundle-desktop-intel:
    runs-on: macos-latest
    name: Bundle Desktop App on Intel macOS
    permissions:
      id-token: write
      contents: read
    steps:
      # Check initial disk space
      - name: Check initial disk space
        run: df -h

      - name: Checkout code
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8  # v6.0.1
        with:
          # Only pass ref if it's explicitly set, otherwise let checkout action use its default behavior
          ref: ${{ inputs.ref != '' && inputs.ref || '' }}

      # Update versions before build
      - name: Update versions
        if: ${{ inputs.version != '' }}
        run: |
          # Update version in Cargo.toml
          sed -i.bak 's/^version = ".*"/version = "'${{ inputs.version }}'"/' Cargo.toml
          rm -f Cargo.toml.bak

          # Update version in package.json
          source ./bin/activate-hermit
          cd ui/desktop
          npm version ${{ inputs.version }} --no-git-tag-version --allow-same-version

      - name: Cache Rust dependencies
        uses: Swatinem/rust-cache@779680da715d629ac1d338a641029a2f4372abb5  # v2.8.2
        with:
          key: intel


      - name: Build goose-server for Intel macOS (x86_64)
        run: |
          source ./bin/activate-hermit
          rustup target add x86_64-apple-darwin
          cargo build --release -p goose-server --target x86_64-apple-darwin



      # Post-build cleanup to free space
      - name: Post-build cleanup
        run: |
          echo "Performing post-build cleanup..."
          # Remove debug artifacts
          rm -rf target/debug || true
          rm -rf target/x86_64-apple-darwin/debug || true
          # Keep only what's needed for the next steps
          rm -rf target/x86_64-apple-darwin/release/deps || true
          rm -rf target/x86_64-apple-darwin/release/build || true
          rm -rf target/x86_64-apple-darwin/release/incremental || true
          # Check disk space after cleanup
          df -h

      - name: Copy binaries into Electron folder
        run: |
          cp target/x86_64-apple-darwin/release/goosed ui/desktop/src/bin/goosed

      - name: Cache npm dependencies
        uses: actions/cache@8b402f58fbc84540c8b491a91e594a4576fec3d7  # v5.0.2
        with:
          path: |
            ui/desktop/node_modules
            .hermit/node/cache
          key: intel-npm-cache-v1-${{ runner.os }}-${{ hashFiles('ui/desktop/package-lock.json') }}
          restore-keys: |
            intel-npm-cache-v1-${{ runner.os }}-
            
      - name: Install dependencies
        run: source ../../bin/activate-hermit && npm ci
        working-directory: ui/desktop

      # Configure Electron builder for Intel architecture
      - name: Configure for Intel build
        run: |
          # Set the architecture to x64 for Intel Mac build
          jq '.build.mac.target[0].arch = "x64"' package.json > package.json.tmp && mv package.json.tmp package.json
        working-directory: ui/desktop

      # Check disk space before bundling
      - name: Check disk space before bundling
        run: df -h

      - name: Generate distribution config
        run: |
          set -euo pipefail
          jq '.provider.api_key = ""' \
            src/distribution/distribution-config.template.json > src/distribution/distribution-config.json
        working-directory: ui/desktop

      - name: Build App
        run: |
          source ../../bin/activate-hermit
          attempt=0
          max_attempts=2
          until [ $attempt -ge $max_attempts ]; do
            npm run bundle:intel && break
            attempt=$((attempt + 1))
            echo "Attempt $attempt failed. Retrying..."
            sleep 5
          done
          if [ $attempt -ge $max_attempts ]; then
            echo "Action failed after $max_attempts attempts."
            exit 1
          fi
        working-directory: ui/desktop

      - name: Resolve bundle paths
        run: |
          set -euo pipefail
          BUNDLE_DIR=$(find ui/desktop/out -maxdepth 1 -type d -name '*-darwin-x64' | head -n 1)
          if [ -z "${BUNDLE_DIR}" ]; then
            echo "Failed to resolve Intel macOS bundle directory"
            exit 1
          fi
          APP_PATH=$(find "${BUNDLE_DIR}" -maxdepth 1 -type d -name '*.app' | head -n 1)
          ZIP_PATH=$(find "${BUNDLE_DIR}" -maxdepth 1 -type f -name '*.zip' | head -n 1)
          if [ -z "${APP_PATH}" ] || [ -z "${ZIP_PATH}" ]; then
            echo "Failed to resolve Intel macOS bundle artifacts"
            exit 1
          fi
          BUNDLE_DIR=$(realpath "${BUNDLE_DIR}")
          APP_PATH=$(realpath "${APP_PATH}")
          ZIP_PATH=$(realpath "${ZIP_PATH}")
          APP_EXECUTABLE="${APP_PATH}/Contents/MacOS/$(basename "${APP_PATH}" .app)"
          {
            echo "BUNDLE_DIR=${BUNDLE_DIR}"
            echo "APP_PATH=${APP_PATH}"
            echo "ZIP_PATH=${ZIP_PATH}"
            echo "APP_EXECUTABLE=${APP_EXECUTABLE}"
          } >> "$GITHUB_ENV"

      - name: Configure AWS credentials
        if: ${{ inputs.signing }}
        uses: aws-actions/configure-aws-credentials@61815dcd50bd041e203e49132bacad1fd04d2708  # v5.1.1
        with:
          role-to-assume: "${{ secrets.OSX_CODESIGN_ROLE }}"
          aws-region: us-west-2

      - name: Codesigning and Notarization
        if: ${{ inputs.signing }}
        run: |
          set -e

          echo "â¬†ï¸ uploading unsigned app"
          source_job_url="https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          unsigned_url="s3://block-goose-artifacts-bucket-production/unsigned/goose-${GITHUB_SHA}-${{ github.run_id }}-intel.zip"

          zip -q -u -r "${ZIP_PATH}" entitlements.plist

          # upload unsigned goose to transfer bucket so it can be passed to lambda
          aws s3 cp --quiet "${ZIP_PATH}" "${unsigned_url}"

          # begin signing
          echo "ðŸš€ launching signing process"
          aws lambda invoke \
            --function-name codesign_helper \
            --cli-binary-format raw-in-base64-out \
            --payload "{\"source_s3_url\": \"${unsigned_url}\", \"source_job_url\": \"${source_job_url}\"}" \
            response.json > /dev/null

          if [ "$(jq -r .statusCode response.json)" != "200" ]; then
            echo "âš ï¸ lambda function did not return expected status code"
            exit 1
          fi

          build_number="$(jq -r .body.build_number response.json)"

          start_time=$(date +%s)

          while sleep 30; do
            aws lambda invoke \
              --function-name codesign_helper \
              --cli-binary-format raw-in-base64-out \
              --payload "{\"source_s3_url\": \"${unsigned_url}\", \"build_number\": \"${build_number}\"}" \
              response.json > /dev/null

            if [ "$(jq -r .statusCode response.json)" != "200" ]; then
              echo "âš ï¸ signing request returned unexpected response code $(jq -r .statusCode response.json):"
              jq . response.json
              exit 1
            fi

            state="$(jq -r .body.state response.json)"

            if [ "${state}" == "completed" ]; then
              echo "âœ… signing complete ($(($(date +%s) - start_time))s)"
              break
            fi

            if [ $(($(date +%s) - start_time)) -ge 3600 ]; then
              echo "âš ï¸ timed out ($(($(date +%s) - start_time))s)"
              exit 1
            fi

            echo "â²ï¸ waiting for signing to complete (${state}: $(($(date +%s) - start_time))s)"
          done

          # parse lambda response
          signed_url=$(jq -r .body.destination_url response.json)

          # download the signed app from S3
          echo "â¬‡ï¸ downloading signed app"
          aws s3 cp --quiet "${signed_url}" "${ZIP_PATH}"
        working-directory: ui/desktop

      - name: Final cleanup before artifact upload
        run: |
          echo "Performing final cleanup..."
          # Remove build artifacts that are no longer needed
          rm -rf target || true
          # Check disk space after cleanup
          df -h

      - name: Normalize artifact filename
        run: |
          set -euo pipefail
          CANONICAL_ZIP_PATH="${BUNDLE_DIR}/InsightStream-goose-macos-x64.zip"
          cp "${ZIP_PATH}" "${CANONICAL_ZIP_PATH}"
          echo "CANONICAL_ZIP_PATH=${CANONICAL_ZIP_PATH}" >> "$GITHUB_ENV"

      - name: Upload Desktop artifact
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f  # v6.0.0
        with:
          name: InsightStream-goose-macos-x64
          path: ${{ env.CANONICAL_ZIP_PATH }}
          if-no-files-found: error

      - name: Quick launch test (macOS)
        if: ${{ inputs.quick_test }}
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          # Ensure no quarantine attributes (if needed)
          xattr -cr "${APP_PATH}"
          echo "Opening ${APP_PATH}..."
          open -g "${APP_PATH}"

          # Give the app a few seconds to start and write logs
          sleep 5

          # Check if it's running
          if pgrep -f "${APP_EXECUTABLE}" > /dev/null; then
            echo "App appears to be running."
          else
            echo "App did not stay open. Possible crash or startup error."
            exit 1
          fi
          # Kill the app to clean up
          pkill -f "${APP_EXECUTABLE}"
